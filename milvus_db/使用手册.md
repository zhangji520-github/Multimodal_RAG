# Multimodal RAG æ•°æ®å¤„ç†ä¸å‘é‡åŒ–ä½¿ç”¨æ‰‹å†Œ

## æ ¸å¿ƒæ¶æ„æ¦‚è§ˆ

### æ•°æ®æµç¨‹
```
Document(æ–‡æœ¬/å›¾åƒ) â†’ ç»“æ„åŒ–å­—å…¸ â†’ DashScopeå‘é‡åŒ– â†’ Milvuså­˜å‚¨
```

## 1. æ•°æ®ç»“æ„è®¾è®¡ (`milvus_db_with_schema.py`)

### 1.1 Milvus Schema å­—æ®µå®šä¹‰
```python
# åŸºç¡€å­—æ®µ
"id": DataType.INT64                    # ä¸»é”®ï¼Œè‡ªå¢
"category": DataType.VARCHAR            # embedding_type: 'text'/'image'
"filename": DataType.VARCHAR            # åŸå§‹æ–‡ä»¶åï¼Œå¦‚ xxx.pdf
"filetype": DataType.VARCHAR            # æ–‡ä»¶ç±»å‹: pdf/md
"title": DataType.VARCHAR               # Headeræ‹¼æ¥: "Header1 --> Header2 --> Header3"
"text": DataType.VARCHAR                # æ–‡æœ¬å†…å®¹æˆ–"å›¾ç‰‡"æ ‡è¯†
"image_path": DataType.VARCHAR          # å›¾ç‰‡æœ¬åœ°è·¯å¾„

# å‘é‡å­—æ®µ
"title_sparse": DataType.SPARSE_FLOAT_VECTOR      # æ ‡é¢˜BM25ç¨€ç–å‘é‡
"text_content_sparse": DataType.SPARSE_FLOAT_VECTOR  # å†…å®¹BM25ç¨€ç–å‘é‡
"text_content_dense": DataType.FLOAT_VECTOR          # 1024ç»´ç¨ å¯†å‘é‡
```

### 1.2 æ ¸å¿ƒè½¬æ¢é€»è¾‘ (`doc_to_dict`)
```python
# æ–‡æœ¬å¤„ç†
if metadata.get('embedding_type') == 'text':
    doc_dict['text'] = doc.page_content
    if doc_dict['title']:
        doc_dict['text'] = doc_dict['title'] + 'ï¼š' + doc.page_content

# å›¾åƒå¤„ç†
if metadata.get('embedding_type') == 'image':
    doc_dict['image_path'] = doc.page_content  # å›¾ç‰‡è·¯å¾„
    doc_dict['text'] = 'å›¾ç‰‡'                  # ç»Ÿä¸€æ ‡è¯†

# æ ‡é¢˜æ‹¼æ¥
headers = [metadata.get(key, '').strip() for key in sorted_header_keys if metadata.get(key, '').strip()]
doc_dict['title'] = ' --> '.join(headers)
```

## 2. å‘é‡åŒ–å¤„ç† (`embeddings_utils.py`)

### 2.1 å·¥ä½œé¡¹æ„å»º (`build_work_items`)
```python
# ä¸ºæ¯ä¸ªæ•°æ®é¡¹åˆ›å»ºå·¥ä½œä»»åŠ¡
for item in expanded_data:
    # æ–‡æœ¬ä»»åŠ¡
    if content: 
        work_items.append(WorkItem(item=item, mode='text', api_image=''))
    
    # å›¾åƒä»»åŠ¡
    if image_path:
        api_img, store_img = normalize_image(image_path)  # æœ¬åœ°æ–‡ä»¶â†’base64
        work_items.append(WorkItem(item=pic_item, mode='image', api_image=api_img))
```

### 2.2 å‘é‡åŒ–æ ¸å¿ƒ (`process_item_with_guard`)
```python
# æ–‡æœ¬å‘é‡åŒ–
if mode == 'text':
    input_data = [{'text': raw_content}]
    ok, embedding = call_dashscope_once(input_data)
    new_item['text_content_dense'] = embedding if ok else []

# å›¾åƒå‘é‡åŒ–  
elif mode == 'image':
    input_data = [{'image': api_image}]  # base64æ ¼å¼
    ok, embedding = call_dashscope_once(input_data)
    new_item['text_content_dense'] = embedding if ok else []
    new_item['text'] = "å›¾ç‰‡"  # è¦†ç›–ä¸ºç»Ÿä¸€æ ‡è¯†
```

### 2.3 å›¾åƒå¤„ç†ç»†èŠ‚
```python
# æœ¬åœ°æ–‡ä»¶ â†’ Base64
def image_to_base64(img_path):
    with open(img_path, "rb") as f:
        b64 = base64.b64encode(f.read()).decode("utf-8")
    return f"data:{mime_type};base64,{b64}"

# å›¾åƒè§„èŒƒåŒ–
def normalize_image(img_path):
    if os.path.isfile(img_path):
        return image_to_base64(img_path)  # è¿”å› (api_format, store_path)
    return "", ""
```

## 3. å…³é”®è¦ç‚¹

### 3.1 å­—æ®µå‘½åä¸€è‡´æ€§
âš ï¸ **é‡è¦**: ç¡®ä¿ä»£ç ä¸­ä½¿ç”¨ `text_content_dense` ä¸ Schema å®šä¹‰ä¸€è‡´
```python
# âœ… æ­£ç¡®
new_item['text_content_dense'] = embedding

# âŒ é”™è¯¯ - ä¼šå¯¼è‡´å­—æ®µä¸åŒ¹é…
new_item['dense'] = embedding
```

### 3.2 å›¾åƒæ•°æ®æµ
```
1. åŸå§‹è·¯å¾„: /path/to/image.png (å­˜å‚¨åœ¨ Document.page_content)
2. Base64è½¬æ¢: data:image/png;base64,xxxxx (ç”¨äºAPIè°ƒç”¨)
3. æ•°æ®åº“å­˜å‚¨: 
   - image_path: /path/to/image.png
   - text: "å›¾ç‰‡"
   - text_content_dense: [å‘é‡æ•°æ®]
```

### 3.3 æ–‡æœ¬æ•°æ®æµ
```
1. åŸå§‹å†…å®¹: Document.page_content + metadata.Headers
2. æ ‡é¢˜æ‹¼æ¥: "Header1 --> Header2 --> Header3"
3. å†…å®¹ç»„åˆ: title + "ï¼š" + page_content (ä»…æ–‡æœ¬ç±»å‹)
4. æ•°æ®åº“å­˜å‚¨:
   - title: æ‹¼æ¥çš„æ ‡é¢˜
   - text: ç»„åˆåçš„å®Œæ•´å†…å®¹
   - text_content_dense: [å‘é‡æ•°æ®]
```

### 3.4 é™æµä¸é‡è¯•
```python
# é€Ÿç‡é™åˆ¶: 120æ¬¡/åˆ†é’Ÿ
limiter = FixedWindowRateLimiter(120, 60)

# 429é‡è¯•æœºåˆ¶
if RETRY_ON_429:
    attempts = 0
    while attempts < MAX_429_RETRIES:
        if res.get('text_content_dense'):
            break
        attempts += 1
        backoff = BASE_BACKOFF * (2 ** (attempts - 1))
        time.sleep(backoff)
```

## 4. ä½¿ç”¨ç¤ºä¾‹

```python
# 1. åˆ›å»ºMilvusé›†åˆ
milvus_vector_save = MilvusVectorSave()
milvus_vector_save.create_collection(is_first=True)

# 2. å¤„ç†æ–‡æ¡£æ•°æ®
docs = splitter.process_md_dir(md_dir, source_filename="xxx.pdf")

# 3. è½¬æ¢å¹¶ä¿å­˜
processed_data = milvus_vector_save.do_save_to_milvus(docs)
```

## 5. æ··åˆæ£€ç´¢åŠŸèƒ½ (`milvus_retrieve.py`)

### 5.1 æ£€ç´¢å™¨åˆå§‹åŒ–
```python
from milvus_db.milvus_retrieve import MilvusRetriever
from pymilvus import MilvusClient

client = MilvusClient(uri=MILVUS_URI, user='root', password='Milvus')
retriever = MilvusRetriever(collection_name=COLLECTION_NAME, milvus_client=client)
```

### 5.2 æ£€ç´¢æ–¹å¼å¯¹æ¯”

| æ£€ç´¢æ–¹å¼ | å­—æ®µ | é€‚ç”¨åœºæ™¯ | ç‰¹ç‚¹ |
|---------|------|----------|------|
| **ç¨ å¯†å‘é‡æ£€ç´¢** | `text_content_dense` | è¯­ä¹‰ç›¸ä¼¼æ€§æœç´¢ | æ”¯æŒæ–‡æœ¬+å›¾åƒï¼Œç†è§£è¯­ä¹‰ |
| **å†…å®¹ç¨€ç–å‘é‡** | `text_content_sparse` | å…³é”®è¯ç²¾ç¡®åŒ¹é… | BM25ç®—æ³•ï¼Œé«˜ç²¾åº¦ |
| **æ ‡é¢˜ç¨€ç–å‘é‡** | `title_sparse` | æ ‡é¢˜å±‚çº§æœç´¢ | ç« èŠ‚å®šä½ï¼Œç»“æ„åŒ–æ£€ç´¢ |

### 5.3 æ ¸å¿ƒæ£€ç´¢æ–¹æ³•

#### ğŸ† æ··åˆæ£€ç´¢ - RRFé‡æ’åºï¼ˆå®˜æ–¹æ¨èï¼‰
```python
# ä½¿ç”¨å€’æ•°æ’åèåˆï¼Œæ— éœ€è°ƒå‚
results = retriever.hybrid_search_with_rrf_ranker(
    query="RBFç¥ç»ç½‘ç»œæ§åˆ¶",
    k=60,  # RRF å‚æ•°ï¼Œé€šå¸¸ä½¿ç”¨é»˜è®¤å€¼
    limit=5
)
```

#### âš–ï¸ æ··åˆæ£€ç´¢ - åŠ æƒé‡æ’åº
```python
# ç²¾ç¡®æ§åˆ¶å„æ£€ç´¢åˆ†æ”¯æƒé‡
results = retriever.hybrid_search_with_weighted_ranker(
    query="RBFç¥ç»ç½‘ç»œæ§åˆ¶", 
    weights=[0.6, 0.3, 0.1],  # [dense, sparse_content, sparse_title]
    limit=5
)
```

#### ğŸ¯ è¯­ä¹‰æœç´¢
```python
# çº¯è¯­ä¹‰ç†è§£ï¼Œæ”¯æŒåŒä¹‰è¯
results = retriever.semantic_search("ç¥ç»ç½‘ç»œ", limit=5)
```

#### ğŸ”¤ å…³é”®è¯æœç´¢
```python
# ç²¾ç¡®å…³é”®è¯åŒ¹é…
results = retriever.keyword_search("RBF", limit=5, search_title=True)
```

### 5.4 é‡æ’åºç­–ç•¥å¯¹æ¯”

| ç­–ç•¥ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ | è°ƒå‚éœ€æ±‚ |
|------|------|----------|----------|
| **RRFRanker** | å€’æ•°æ’åèåˆï¼Œç¨³å®šæ€§å¥½ | é€šç”¨æœç´¢ï¼Œæ— ç»éªŒè°ƒå‚ | ä»…éœ€è°ƒèŠ‚ k å€¼ |
| **WeightedRanker** | åŠ æƒçº¿æ€§ç»„åˆï¼Œå¯æ§æ€§å¼º | ç‰¹å®šåœºæ™¯ä¼˜åŒ– | éœ€è¦æƒé‡è°ƒä¼˜ |

### 5.5 æƒé‡é…ç½®å»ºè®®ï¼ˆWeightedRankerï¼‰

| åœºæ™¯ | dense | sparse_content | sparse_title | è¯´æ˜ |
|------|-------|---------------|--------------|------|
| **é€šç”¨æœç´¢** | 0.6 | 0.3 | 0.1 | å¹³è¡¡è¯­ä¹‰ä¸å…³é”®è¯ |
| **ä¸“ä¸šæœ¯è¯­** | 0.4 | 0.5 | 0.1 | å…³é”®è¯åŒ¹é…ä¼˜å…ˆ |
| **ç« èŠ‚å®šä½** | 0.3 | 0.2 | 0.5 | æ ‡é¢˜ç»“æ„å¯¼èˆª |
| **å›¾åƒç›¸å…³** | 0.8 | 0.2 | 0.0 | è¯­ä¹‰ç†è§£ä¸ºä¸» |

### 5.6 RRF ç®—æ³•åŸç†
```python
# RRF (Reciprocal Rank Fusion) å…¬å¼
# å¯¹äºæ–‡æ¡£ d åœ¨å„æ£€ç´¢ç»“æœä¸­çš„æ’å rank_i
RRF_score(d) = Î£(1 / (k + rank_i))

# å…¶ä¸­ k æ˜¯å¹³æ»‘å‚æ•°ï¼Œé€šå¸¸è®¾ä¸º 60
# ä¼˜ç‚¹ï¼šæ— éœ€æƒé‡è°ƒä¼˜ï¼Œå¯¹ä¸åŒåˆ†å¸ƒçš„åˆ†æ•°æœ‰å¾ˆå¥½çš„é²æ£’æ€§
```

## 6. ä½¿ç”¨ç¤ºä¾‹

### å®Œæ•´å·¥ä½œæµ
```python
# 1. æ•°æ®å¤„ç†ä¸å­˜å‚¨
splitter = MarkdownDirSplitter(images_output_dir="./output/images")
docs = splitter.process_md_dir(md_dir, source_filename="paper.pdf")

milvus_save = MilvusVectorSave()
milvus_save.create_collection(is_first=True)
milvus_save.do_save_to_milvus(docs)

# 2. åˆå§‹åŒ–æ£€ç´¢å™¨
from pymilvus import MilvusClient
client = MilvusClient(uri=MILVUS_URI, user='root', password='Milvus')
retriever = MilvusRetriever(milvus_client=client)

# 3. æ··åˆæ£€ç´¢ï¼ˆæ¨èä½¿ç”¨RRFï¼‰
rrf_results = retriever.hybrid_search_with_rrf_ranker(
    query="ç¥ç»ç½‘ç»œæ§åˆ¶æ–¹æ³•",
    k=60,
    limit=5
)

# 4. åŠ æƒæ£€ç´¢ï¼ˆéœ€è¦è°ƒå‚ï¼‰
weighted_results = retriever.hybrid_search_with_weighted_ranker(
    query="ç¥ç»ç½‘ç»œæ§åˆ¶æ–¹æ³•",
    weights=[0.6, 0.3, 0.1],
    limit=5
)

# 5. ç»“æœå¤„ç†
for result in rrf_results:
    entity = result.get('entity', {})
    distance = result.get('distance', 0)
    print(f"æ ‡é¢˜: {entity.get('title')}")
    print(f"å†…å®¹: {entity.get('text')[:100]}...")
    print(f"ç±»å‹: {entity.get('category')}")
    print(f"ç›¸ä¼¼åº¦: {distance:.4f}")
```

### ğŸ†š ç­–ç•¥é€‰æ‹©æŒ‡å—

```python
# åœºæ™¯ 1: é€šç”¨æœç´¢ï¼Œä¸æƒ³è°ƒå‚ â†’ ä½¿ç”¨ RRF
results = retriever.hybrid_search_with_rrf_ranker(query="æŸ¥è¯¢å†…å®¹")

# åœºæ™¯ 2: éœ€è¦ç²¾ç¡®æ§åˆ¶æƒé‡ â†’ ä½¿ç”¨ WeightedRanker  
results = retriever.hybrid_search_with_weighted_ranker(
    query="æŸ¥è¯¢å†…å®¹",
    weights=[0.7, 0.2, 0.1]  # æ ¹æ®åœºæ™¯è°ƒæ•´
)

# åœºæ™¯ 3: çº¯è¯­ä¹‰æœç´¢
results = retriever.semantic_search(query="æŸ¥è¯¢å†…å®¹")

# åœºæ™¯ 4: çº¯å…³é”®è¯æœç´¢
results = retriever.keyword_search(query="æŸ¥è¯¢å†…å®¹")
```

## 7. å¸¸è§é—®é¢˜

### Q: ä¸ºä»€ä¹ˆå›¾åƒçš„titleå­—æ®µä¼šæ˜¯è·¯å¾„ï¼Ÿ
A: å›¾åƒDocumentç»§æ‰¿äº†å½“å‰æ–‡æœ¬å—çš„HeaderçŠ¶æ€ï¼Œå¦‚æœHeaderå­—æ®µè¢«æ±¡æŸ“æˆ–çŠ¶æ€è®°å½•å™¨å¼‚å¸¸ï¼Œå¯èƒ½å¯¼è‡´è·¯å¾„ä¿¡æ¯è¢«è¯¯å†™å…¥titleå­—æ®µã€‚

### Q: denseå­—æ®µé”™è¯¯å¦‚ä½•è§£å†³ï¼Ÿ
A: ç¡®ä¿ä»£ç ä¸­ä½¿ç”¨ `text_content_dense` è€Œé `dense`ï¼Œä¿æŒä¸Schemaå®šä¹‰ä¸€è‡´ã€‚

### Q: RRF å’Œ WeightedRanker åº”è¯¥é€‰æ‹©å“ªä¸ªï¼Ÿ
A: 
- **é€‰æ‹© RRF**ï¼šé€šç”¨åœºæ™¯ï¼Œä¸æƒ³è°ƒå‚ï¼Œè¿½æ±‚ç¨³å®šæ€§
- **é€‰æ‹© WeightedRanker**ï¼šç‰¹å®šåœºæ™¯ä¼˜åŒ–ï¼Œæœ‰è°ƒå‚ç»éªŒ

### Q: æ··åˆæ£€ç´¢æ•ˆæœä¸å¥½æ€ä¹ˆè°ƒä¼˜ï¼Ÿ
A: 
1. **ä¼˜å…ˆå°è¯• RRF**ï¼š`hybrid_search_with_rrf_ranker(k=60)`
2. **æ£€æŸ¥å•é¡¹æ£€ç´¢**ï¼šéªŒè¯è¯­ä¹‰æœç´¢å’Œå…³é”®è¯æœç´¢çš„ç‹¬ç«‹æ•ˆæœ
3. **è°ƒæ•´æƒé‡**ï¼šä»…å½“ä½¿ç”¨ WeightedRanker æ—¶ï¼Œæ ¹æ®ä¸šåŠ¡åœºæ™¯è°ƒæ•´ `[dense, sparse_content, sparse_title]`
4. **æ‰©å¤§å€™é€‰é›†**ï¼šå¢åŠ  `limit` å‚æ•°
5. **éªŒè¯æŸ¥è¯¢å‘é‡**ï¼šç¡®è®¤ DashScope API è°ƒç”¨æˆåŠŸ

### Q: RRF çš„ k å€¼å¦‚ä½•è®¾ç½®ï¼Ÿ
A: 
- é»˜è®¤å€¼ 60 é€‚ç”¨äºå¤§å¤šæ•°åœºæ™¯
- k å€¼è¶Šå°ï¼Œæ’åé å‰çš„ç»“æœå½±å“è¶Šå¤§
- k å€¼è¶Šå¤§ï¼Œç»“æœæ’åå·®å¼‚å½±å“è¶Šå°
- å»ºè®®èŒƒå›´ï¼š30-100

### Q: å›¾åƒæ— æ³•å‘é‡åŒ–æ€ä¹ˆåŠï¼Ÿ
A: æ£€æŸ¥å›¾åƒæ–‡ä»¶æ˜¯å¦å­˜åœ¨ã€å¤§å°æ˜¯å¦è¶…è¿‡3MBé™åˆ¶ã€API keyæ˜¯å¦æœ‰æ•ˆã€‚
