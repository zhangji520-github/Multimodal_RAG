# Multimodal RAG 数据处理与向量化使用手册

## 核心架构概览

### 数据流程
```
Document(文本/图像) → 结构化字典 → DashScope向量化 → Milvus存储
```

## 1. 数据结构设计 (`milvus_db_with_schema.py`)

### 1.1 Milvus Schema 字段定义
```python
# 基础字段
"id": DataType.INT64                    # 主键，自增
"category": DataType.VARCHAR            # embedding_type: 'text'/'image'
"filename": DataType.VARCHAR            # 原始文件名，如 xxx.pdf
"filetype": DataType.VARCHAR            # 文件类型: pdf/md
"title": DataType.VARCHAR               # Header拼接: "Header1 --> Header2 --> Header3"
"text": DataType.VARCHAR                # 文本内容或"图片"标识
"image_path": DataType.VARCHAR          # 图片本地路径

# 向量字段
"title_sparse": DataType.SPARSE_FLOAT_VECTOR      # 标题BM25稀疏向量
"text_content_sparse": DataType.SPARSE_FLOAT_VECTOR  # 内容BM25稀疏向量
"text_content_dense": DataType.FLOAT_VECTOR          # 1024维稠密向量
```

### 1.2 核心转换逻辑 (`doc_to_dict`)
```python
# 文本处理
if metadata.get('embedding_type') == 'text':
    doc_dict['text'] = doc.page_content
    if doc_dict['title']:
        doc_dict['text'] = doc_dict['title'] + '：' + doc.page_content

# 图像处理
if metadata.get('embedding_type') == 'image':
    doc_dict['image_path'] = doc.page_content  # 图片路径
    doc_dict['text'] = '图片'                  # 统一标识

# 标题拼接
headers = [metadata.get(key, '').strip() for key in sorted_header_keys if metadata.get(key, '').strip()]
doc_dict['title'] = ' --> '.join(headers)
```

## 2. 向量化处理 (`embeddings_utils.py`)

### 2.1 工作项构建 (`build_work_items`)
```python
# 为每个数据项创建工作任务
for item in expanded_data:
    # 文本任务
    if content: 
        work_items.append(WorkItem(item=item, mode='text', api_image=''))
    
    # 图像任务
    if image_path:
        api_img, store_img = normalize_image(image_path)  # 本地文件→base64
        work_items.append(WorkItem(item=pic_item, mode='image', api_image=api_img))
```

### 2.2 向量化核心 (`process_item_with_guard`)
```python
# 文本向量化
if mode == 'text':
    input_data = [{'text': raw_content}]
    ok, embedding = call_dashscope_once(input_data)
    new_item['text_content_dense'] = embedding if ok else []

# 图像向量化  
elif mode == 'image':
    input_data = [{'image': api_image}]  # base64格式
    ok, embedding = call_dashscope_once(input_data)
    new_item['text_content_dense'] = embedding if ok else []
    new_item['text'] = "图片"  # 覆盖为统一标识
```

### 2.3 图像处理细节
```python
# 本地文件 → Base64
def image_to_base64(img_path):
    with open(img_path, "rb") as f:
        b64 = base64.b64encode(f.read()).decode("utf-8")
    return f"data:{mime_type};base64,{b64}"

# 图像规范化
def normalize_image(img_path):
    if os.path.isfile(img_path):
        return image_to_base64(img_path)  # 返回 (api_format, store_path)
    return "", ""
```

## 3. 关键要点

### 3.1 字段命名一致性
⚠️ **重要**: 确保代码中使用 `text_content_dense` 与 Schema 定义一致
```python
# ✅ 正确
new_item['text_content_dense'] = embedding

# ❌ 错误 - 会导致字段不匹配
new_item['dense'] = embedding
```

### 3.2 图像数据流
```
1. 原始路径: /path/to/image.png (存储在 Document.page_content)
2. Base64转换: data:image/png;base64,xxxxx (用于API调用)
3. 数据库存储: 
   - image_path: /path/to/image.png
   - text: "图片"
   - text_content_dense: [向量数据]
```

### 3.3 文本数据流
```
1. 原始内容: Document.page_content + metadata.Headers
2. 标题拼接: "Header1 --> Header2 --> Header3"
3. 内容组合: title + "：" + page_content (仅文本类型)
4. 数据库存储:
   - title: 拼接的标题
   - text: 组合后的完整内容
   - text_content_dense: [向量数据]
```

### 3.4 限流与重试
```python
# 速率限制: 120次/分钟
limiter = FixedWindowRateLimiter(120, 60)

# 429重试机制
if RETRY_ON_429:
    attempts = 0
    while attempts < MAX_429_RETRIES:
        if res.get('text_content_dense'):
            break
        attempts += 1
        backoff = BASE_BACKOFF * (2 ** (attempts - 1))
        time.sleep(backoff)
```

## 4. 使用示例

```python
# 1. 创建Milvus集合
milvus_vector_save = MilvusVectorSave()
milvus_vector_save.create_collection(is_first=True)

# 2. 处理文档数据
docs = splitter.process_md_dir(md_dir, source_filename="xxx.pdf")

# 3. 转换并保存
processed_data = milvus_vector_save.do_save_to_milvus(docs)
```

## 5. 混合检索功能 (`milvus_retrieve.py`)

### 5.1 检索器初始化
```python
from milvus_db.milvus_retrieve import MilvusRetriever
from pymilvus import MilvusClient

client = MilvusClient(uri=MILVUS_URI, user='root', password='Milvus')
retriever = MilvusRetriever(collection_name=COLLECTION_NAME, milvus_client=client)
```

### 5.2 检索方式对比

| 检索方式 | 字段 | 适用场景 | 特点 |
|---------|------|----------|------|
| **稠密向量检索** | `text_content_dense` | 语义相似性搜索 | 支持文本+图像，理解语义 |
| **内容稀疏向量** | `text_content_sparse` | 关键词精确匹配 | BM25算法，高精度 |
| **标题稀疏向量** | `title_sparse` | 标题层级搜索 | 章节定位，结构化检索 |

### 5.3 核心检索方法

#### 🏆 混合检索 - RRF重排序（官方推荐）
```python
# 使用倒数排名融合，无需调参
results = retriever.hybrid_search_with_rrf_ranker(
    query="RBF神经网络控制",
    k=60,  # RRF 参数，通常使用默认值
    limit=5
)
```

#### ⚖️ 混合检索 - 加权重排序
```python
# 精确控制各检索分支权重
results = retriever.hybrid_search_with_weighted_ranker(
    query="RBF神经网络控制", 
    weights=[0.6, 0.3, 0.1],  # [dense, sparse_content, sparse_title]
    limit=5
)
```

#### 🎯 语义搜索
```python
# 纯语义理解，支持同义词
results = retriever.semantic_search("神经网络", limit=5)
```

#### 🔤 关键词搜索
```python
# 精确关键词匹配
results = retriever.keyword_search("RBF", limit=5, search_title=True)
```

### 5.4 重排序策略对比

| 策略 | 特点 | 适用场景 | 调参需求 |
|------|------|----------|----------|
| **RRFRanker** | 倒数排名融合，稳定性好 | 通用搜索，无经验调参 | 仅需调节 k 值 |
| **WeightedRanker** | 加权线性组合，可控性强 | 特定场景优化 | 需要权重调优 |

### 5.5 权重配置建议（WeightedRanker）

| 场景 | dense | sparse_content | sparse_title | 说明 |
|------|-------|---------------|--------------|------|
| **通用搜索** | 0.6 | 0.3 | 0.1 | 平衡语义与关键词 |
| **专业术语** | 0.4 | 0.5 | 0.1 | 关键词匹配优先 |
| **章节定位** | 0.3 | 0.2 | 0.5 | 标题结构导航 |
| **图像相关** | 0.8 | 0.2 | 0.0 | 语义理解为主 |

### 5.6 RRF 算法原理
```python
# RRF (Reciprocal Rank Fusion) 公式
# 对于文档 d 在各检索结果中的排名 rank_i
RRF_score(d) = Σ(1 / (k + rank_i))

# 其中 k 是平滑参数，通常设为 60
# 优点：无需权重调优，对不同分布的分数有很好的鲁棒性
```

## 6. 使用示例

### 完整工作流
```python
# 1. 数据处理与存储
splitter = MarkdownDirSplitter(images_output_dir="./output/images")
docs = splitter.process_md_dir(md_dir, source_filename="paper.pdf")

milvus_save = MilvusVectorSave()
milvus_save.create_collection(is_first=True)
milvus_save.do_save_to_milvus(docs)

# 2. 初始化检索器
from pymilvus import MilvusClient
client = MilvusClient(uri=MILVUS_URI, user='root', password='Milvus')
retriever = MilvusRetriever(milvus_client=client)

# 3. 混合检索（推荐使用RRF）
rrf_results = retriever.hybrid_search_with_rrf_ranker(
    query="神经网络控制方法",
    k=60,
    limit=5
)

# 4. 加权检索（需要调参）
weighted_results = retriever.hybrid_search_with_weighted_ranker(
    query="神经网络控制方法",
    weights=[0.6, 0.3, 0.1],
    limit=5
)

# 5. 结果处理
for result in rrf_results:
    entity = result.get('entity', {})
    distance = result.get('distance', 0)
    print(f"标题: {entity.get('title')}")
    print(f"内容: {entity.get('text')[:100]}...")
    print(f"类型: {entity.get('category')}")
    print(f"相似度: {distance:.4f}")
```

### 🆚 策略选择指南

```python
# 场景 1: 通用搜索，不想调参 → 使用 RRF
results = retriever.hybrid_search_with_rrf_ranker(query="查询内容")

# 场景 2: 需要精确控制权重 → 使用 WeightedRanker  
results = retriever.hybrid_search_with_weighted_ranker(
    query="查询内容",
    weights=[0.7, 0.2, 0.1]  # 根据场景调整
)

# 场景 3: 纯语义搜索
results = retriever.semantic_search(query="查询内容")

# 场景 4: 纯关键词搜索
results = retriever.keyword_search(query="查询内容")
```

## 7. 常见问题

### Q: 为什么图像的title字段会是路径？
A: 图像Document继承了当前文本块的Header状态，如果Header字段被污染或状态记录器异常，可能导致路径信息被误写入title字段。

### Q: dense字段错误如何解决？
A: 确保代码中使用 `text_content_dense` 而非 `dense`，保持与Schema定义一致。

### Q: RRF 和 WeightedRanker 应该选择哪个？
A: 
- **选择 RRF**：通用场景，不想调参，追求稳定性
- **选择 WeightedRanker**：特定场景优化，有调参经验

### Q: 混合检索效果不好怎么调优？
A: 
1. **优先尝试 RRF**：`hybrid_search_with_rrf_ranker(k=60)`
2. **检查单项检索**：验证语义搜索和关键词搜索的独立效果
3. **调整权重**：仅当使用 WeightedRanker 时，根据业务场景调整 `[dense, sparse_content, sparse_title]`
4. **扩大候选集**：增加 `limit` 参数
5. **验证查询向量**：确认 DashScope API 调用成功

### Q: RRF 的 k 值如何设置？
A: 
- 默认值 60 适用于大多数场景
- k 值越小，排名靠前的结果影响越大
- k 值越大，结果排名差异影响越小
- 建议范围：30-100

### Q: 图像无法向量化怎么办？
A: 检查图像文件是否存在、大小是否超过3MB限制、API key是否有效。
